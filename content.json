{"meta":{"title":"pursur_world","subtitle":"","description":"我面朝着大海，春暖花开","author":"Cain_pursuer","url":"https://pursur314.github.io","root":"/"},"pages":[],"posts":[{"title":"深入类和对象","slug":"深入类和对象","date":"2022-01-13T09:01:44.000Z","updated":"2022-01-13T09:03:41.199Z","comments":true,"path":"2022/01/13/深入类和对象/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"三. 深入类和对象鸭子类型和多态 什么是鸭子类型？（python的核心） 只要行为，性格像鸭子，就把它看作鸭子。在python中，其实就是只要具有相同的特性，那么就可以把它归为一类。 例如list，set，tuple都是可迭代对象，都是一只鸭子（他们都包含一些相同的魔法函数） 多态 同一种事物，但具有不同的形态，人和其他动物都是动物，都可以走，但人和其他动物不一样，由此体现了动物的多态。 在python中，多态可以通过继承的方式体现，子类可以调用父类的方法函数 多态性（注意和多态的区分） 多个不同功能的函数，具有相同的函数名，在python中，python本身就具有多态性，对于不同的类对象，可以有相同的函数名，但实现的功能不一样，我们都可以用相同的方法进行调用 123456789101112131415161718192021222324252627282930# dclass Animal: def run(self): raise AttributeError(&#x27;子类必须实现这个方法&#x27;) # 体现多态class People(Animal): def run(self): print(&#x27;人正在走&#x27;) class Pig(Animal): def run(self): print(&#x27;pig is walking&#x27;) class Dog(Animal): def run(self): print(&#x27;dog is running&#x27;) peo=People()pig=Pig()dog=Dog() peo.run()pig.run()dog.run()animal = [peo,pig,dog]for i in animal: i.run() # 体现多态性 +++ 抽象基类 目的 为了判断某个对象的类型 为了使某个对象的子类必须实现父类的某些方法 12345678910111213141516171819202122232425262728293031#使子类在实例化时就抛出异常class A(metaclass= abc.ABCMeta): @abc.abstractmethod def get(self,key): pass @abc.abstractmethod def getvalue(self,key,value): passclass B(A): passB() # 抛出异常#使子类在调用父类方法时抛出异常class C(): def get(self,key): raise NotImplementedError def getvalue(self,key,value): raise NotImplementedErrorclass D(C): passtestD = D()testD.get(&quot;dk&quot;) # 抛出异常 +++ type和isinstance的区别 type实质返回的是将该对象实例化的类，不能判断是否是该类的父类将其实例化 isinstance（）实质判断的是是否属于该类型，也就可以判断与父类的关系 1__base__ # 可以查看所有的基类 +++ 类的深入 类的属性和实例属性及其查找顺序 类和他的实例是两个不同的对象，在查找其属性时自下而上查找 多继承的查找方法 c3算法：python 独有的mro算法，解决钻石（菱形）的继承问题，以及Y型问题 123456789101112131415161718192021222324252627282930313233# 菱形继承# 当一个类d继承的两个类b，c中继承了相同的一个类a，而继承的b，c类中均对a中的同一个方法进行了改写，具有不同的功能，由此产生问题class a1(): passclass b1(a1): passclass c1(a1): passclass d1(b1,c1): passprint(d1.__mro__)# y型继承class a2(): passclass b2(): passclass c2(a2): passclass d2(b2): passclass e2(c2,d2): passprint(e2.__mro__) 总结：本地优先，先在本地查找，然后按继承的列表顺序查找，如果在查找的父类中继承了其他类，那么继续向上查找，没有的话才会查找相同级别的下一个父类 静态方法和类方法以及实例方法的区别 静态方法和类方法不需要实例化就可以实现，而实例方法需要实例化后才可以实现 静态方法没有传入该类，需要用@staticmethod 装饰器 类方法传入了所在类，cls（类似于self），需要用@classmethod 装饰 类的私有变量和私有方法 （变量和方法都是该类的属性） 在属性或方法前加双下划线，但不是绝对私有化，可以通过_class__attr得到， 只能在该对象的内部使用，其子类或实例都不能调用 12345678910111213141516171819202122232425class Date(object): __initiu_date = &quot;0000_00_00&quot; def __init__(self,year,month,day): self.year = year self.month = month self.day = day @staticmethod def __parse_date(string): year,month,day = tuple(string.split(&quot;-&quot;)) return Date(year,month,day) @classmethod def parsing_date(cls,string): year, month, day = tuple(string.split(&quot;-&quot;)) return cls(year, month, day) def __str__(self): return f&quot;&#123;self.month&#125; &#123;self.day&#125; &#123;self.year&#125;&quot;date = &quot;2021-11-8&quot;today = Date.parsing_date(date)toda = Date._Date__parse_date(date) #得到私有方法print(today,toda)print(today._Date__initiu_date) #得到私有变量","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"魔法函数","slug":"魔法函数","date":"2022-01-13T08:59:46.000Z","updated":"2022-01-13T09:03:47.405Z","comments":true,"path":"2022/01/13/魔法函数/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/","excerpt":"","text":"二.魔法函数什么是魔法函数？以双下划线（__)开头和结尾的，python内置，解释器自动调用，用户无法定义其名称的函数 魔法函数的影响 改变或增加对象的类型 魔法函数实际是python的一种数据模型，能够对内部进行优化，提高性能 +++ 由于魔法函数过多，其后会慢慢学习，只选用几个例子 +++ 魔法函数的例子123456789101112131415161718192021222324class company(object): &quot;&quot;&quot; 通过__doc__查看 &quot;&quot;&quot; def __init__(self,employee): self.employee = employee #变成一个可迭代类型的对象（与iter类似） def __getitem__(self,item): return self.employee[item] #变成一个list类型的对象 def __len__(self): return len(self.employee) def __str__(self): &quot;&quot;&quot;变成一个str类型的对象&quot;&quot;&quot; return &quot;.&quot;.join(self.employee)com = company([&quot;petter&quot;,&quot;Tom&quot;])for item in com: print(item)","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"一切皆对象","slug":"一切皆对象","date":"2022-01-13T08:54:30.000Z","updated":"2022-01-13T08:58:12.993Z","comments":true,"path":"2022/01/13/一切皆对象/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一. 一切皆对象python中，一切皆对象什么是对象？ 可以被赋值给一个对象 可以被添加到一个列表或其他序列中，作为一个元素 可以被用作参数传递，或返回值返回 +++ 对象的类型 python基本的数据类型，像列表，是一个列表对象，除此之外，还有很多，像生成器，迭代器对象等 +++ type 与object，class 的关系 object是每一个类都必须要继承的一个基类，是type的实例 type 是最基础的类，自己实例化自己，继承object class 保留关键字，定义类 123print(type(object))print(type(type))print(type(int)) 结果都是type的实例对象 +++ 静态语言和动态语言的区别pyhton是一门动态语言 静态语言需要指定每一个变量的类型，动态语言不用 静态语言需要一个编译过程，可以发现错误，而动态语言不需要，只有运行时才能发现错误 静态语言的多态需要继承，而动态语言与生俱来","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"typora的使用","slug":"typora的使用","date":"2022-01-09T08:30:33.000Z","updated":"2022-01-13T08:58:50.811Z","comments":true,"path":"2022/01/09/typora的使用/","link":"","permalink":"https://pursur314.github.io/2022/01/09/typora%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"markdown 语法 完整更详细的操作参考 (6条消息) 最齐的Typora使用教程_水木子的博客-CSDN博客_typora使用教程 标题 ctrl + 数字键（数字对应几级标题，一共六级），注意ctrl +0 是普通段落 #加上一个空格，然后才是标题内容 字体 斜体 用一对 * 或 _ 括住的字体表示斜体 斜体 ctrl + I 粗体 用一对 ***或___括住的字体表示粗体 ctrl + B 各种线 分割线 连续的三个* 或+ 或-： +++ 删除线 用一对~~括住的文本 删除线 下划线 ctrl + U 序列 无序序列 ctrl + shift + 】 用+或*或- 加上一个空格来表示 有序序列 ctrl + shift +【 用数字加上一个空格来表示 第一个 第二个 列表的嵌套 第一项 第二项 第一项 第一项 缩进的距离 tab 或者 ctrl + 【 引用 使用 &gt;加上空格，用于引用他人文章的内容 退出 delete 或 enter 引用的内容 引用的嵌套 一级 二级 代码 ctrl + shfit + k 如果是一行代码，可以使用段内代码块来表示，用一对 **`**（数字1旁边的符号）括住代码。 退出代码块：ctrl + enter print(&quot;hello,world&quot;) 链接 ctrl + K 这是菜鸟链接 图片 ctrl + shift + I ![本地图片](../../../../图片/Camera Roll/wallhaven-pkgkkp.png) 可以直接复制粘贴图片 ，但需要在偏好设置中设置一下图片的保存地址 表格 ctrl + T 对齐方式 这是左对齐 这是右对齐 中间对齐 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格","categories":[{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://pursur314.github.io/tags/%E8%BD%AF%E4%BB%B6/"}],"author":"pursur"},{"title":"Hello World","slug":"hello-world","date":"2022-01-08T02:40:25.924Z","updated":"2022-01-08T02:39:21.837Z","comments":true,"path":"2022/01/08/hello-world/","link":"","permalink":"https://pursur314.github.io/2022/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"},{"name":"软件","slug":"软件","permalink":"https://pursur314.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]}