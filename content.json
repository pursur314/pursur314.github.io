{"meta":{"title":"pursur_world","subtitle":"","description":"我面朝着大海，春暖花开","author":"Cain_pursuer","url":"https://pursur314.github.io","root":"/"},"pages":[],"posts":[{"title":"一些标签的区分","slug":"一些标签的区分","date":"2022-03-21T12:36:42.000Z","updated":"2022-03-21T12:59:04.811Z","comments":true,"path":"2022/03/21/一些标签的区分/","link":"","permalink":"https://pursur314.github.io/2022/03/21/%E4%B8%80%E4%BA%9B%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%86/","excerpt":"","text":"一些常用标签和属性的区分id，class，name的区分 id ：一个html中只能有一个id ，不能重复 class ：一个html文档中可以有多个，且一个元素可以有多个class属性 name：在html文档中用于提交form表单域的信息，定义了name的表单元素，服务器才可以接受到数据。 src ，href，url的区分 src ：Source，一般用于外部资源的引入，在引入的过程中，会暂停其他文件的下载和解析，一般多用于script，img，iframe等标签中 href：hype text reference，外部资源的引用，一般用于建立元素和文档的链接，一般用于a，link标签中 url：Uniform Resource Locator，统一资源定位符，网页的网址","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://pursur314.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"pursur"},{"title":"进程，线程，协程的学习","slug":"进程，线程，协程的学习","date":"2022-03-05T11:58:36.000Z","updated":"2022-03-17T11:10:45.509Z","comments":true,"path":"2022/03/05/进程，线程，协程的学习/","link":"","permalink":"https://pursur314.github.io/2022/03/05/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"模型（初步感性认识）工厂模型设想有一个老板 他想要赚钱致富，于是想到办工厂（进程） 为了生产产品，他花钱办了许多个工厂同时生产（多进程），由于每个工厂办在不同的地方，所以工厂之间没有联系（进程之间无法相互通信） 在每个工厂里，有许多不同的流水线，每个流水线有一名或多个工人（线程），一个工厂里可以自由交流（线程之间可以相互通信） 为了提高效率，一条流水线，老板要招收多个工人一起工作（多线程）。 然而，为了进一步提高效率，老板想出了一个办法，让一名工人在等待其他工人时去干其他的活（协程）。 +++ 多任务多任务实现原理 操作系统可以同时运⾏多个任务。打个 ⽐⽅，你⼀边在⽤浏览器上⽹，⼀边在听MP3，⼀边在⽤Word赶作业，这就是多任务，⾄少同时有3个任务正在运⾏。 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。 假设每一个cpu有四个核心，每一个核心执行一个任务，也就实现了多任务。 多任务实现方式单核实现​ 操作系统让每一个任务交替轮流执行，由于cpu的执行速度很快，看起来就像每个任务同时执行。 +++ 多核实现​ 操作系统，让每一个任务轮流交给每个核心执行，如果任务的数量小于或等于核心的数量，就实现了真正的并行，任务大于核心的数量，便与单核实现类似。 多进程进程的认识 进程(process)是系统进行资源调度的最小单位 进程是系统进行资源分配和调度的一个独立单元 多进程的实现方式 一般方法 12345678910111213141516171819202122232425262728from multiprocessing import Process, Pooldef func(n): s = time.time() print(&#x27;开始执行函数&#x27;) time.sleep(2) print(&#x27;函数执行完成了&#x27;)def fun(n): for i in range(n): print(i)if __name__ == &#x27;__main__&#x27;: proc_list = [] # 对于使用多个进程时，是并发的，但实际上是分配给了一个cpu，所以会有最后一个被启动的子进程， # 主进程只会等待最后一个被启动的子进程完成后结束，而不管其他的子进程是否结束 for i in range(5, 9): process = Process(target=func, args=(0,)) proc_list.append(process) process.start() # 使主进程等待最后一个子进程结束 for i in proc_list: i.join() # 设置等待的时长 # i.join(timeout=3) 队列（理解为单人卫生间） 12345678910111213141516171819202122232425262728293031323334353637383940# 管道是基于socket搭建的# 队列是基于管道和锁搭建的，也就实现了进程之间的相互通信# 就是把每一个进程放到默认加入锁，放入管道中，挨个执行，同时保证数据安全# 队列遵循先进先出的原则from multiprocessing import Process, Queueimport json, timewith open(&quot;ticket.txt&quot;,&quot;w&quot;) as f: json.dump(&#x27;&#123;&quot;ticket&quot;: 1&#125;&#x27;,f) # 查找票数def search(name): with open(&quot;ticket.txt&quot;) as f: dic = json.load(f) print(f&quot;&#123;name&#125;查询到了&#123;dic[&#x27;ticket&#x27;]&#125;张票&quot;)# 买票def get(name): dic = json.load(open(&quot;ticket.txt&quot;)) time.sleep(1) # 由于操作过快，会导致所有的客户无法查找到票 if dic[&quot;ticket&quot;] &gt;= 1: dic[&quot;ticket&quot;] -= 1 json.dump(dic, open(&quot;ticket.txt&quot;, &quot;w&quot;)) print(f&quot;&#123;name&#125;买到了一张票&quot;) else: print(&quot;没票了&quot;)def run(name, queue): search(name) queue.put(get(name)) # 把进程对象放入队列中if __name__ == &#x27;__main__&#x27;: q = Queue() # for i in range(10): p = Process(target=run, args=(f&quot;person&#123;i&#125;&quot;, q)) p.start() q.get() # 把进程对象从队列中拿出 信号量（理解为公共厕所）和锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import jsonimport timefrom multiprocessing import Process, Lock, Semaphoredef search(name): with open(&quot;ticket.txt&quot;) as f: dic = json.load(f) print(f&quot;&#123;name&#125;查询到了&#123;dic[&#x27;ticket&#x27;]&#125;张票&quot;)def get(name): dic = json.load(open(&quot;ticket.txt&quot;)) time.sleep(1) # 由于操作过快，会导致所有的客户无法查找到票 if dic[&quot;ticket&quot;] &gt;= 1: dic[&quot;ticket&quot;] -= 1 json.dump(dic, open(&quot;ticket.txt&quot;, &quot;w&quot;)) print(f&quot;&#123;name&#125;买到了一张票&quot;) else: print(&quot;没票了&quot;)def task(name, semepore): # lock=None, search(name) lock.acquire() # 拿到锁 get(name) lock.release() # 释放锁 def task(name, semepore): # lock=None, search(name) semepore.acquire() # 拿到锁 get(name) semepore.release() # 释放锁if __name__ == &#x27;__main__&#x27;: tasks = [] # 进程之间不共享数据，但共享同一个文件夹， # 导致一张票，被所有人买到 # for i in range(10): # ta = Process(target=task, args=(f&quot;person&#123;i&#125;&quot;,)) # ta.start() # lock类，加锁处理，并发变为串行 # 使所有进程能同时访问同一个文件，但只有一个能对文件进行操作 lock = Lock() # for i in range(10): # ta = Process(target=task, args=(f&quot;person&#123;i&#125;&quot;,)) # ta.start() # tasks.append(ta) # for i in tasks: # i.join() # Semaphore类，计数器加锁，信号量 # 使多个人能够拿到锁，同时进行操作 se = Semaphore(4) for i in range(10): ta = Process(target=task, args=(f&quot;person&#123;i&#125;&quot;, se)) ta.start() 定义自己的进程类 123456789101112131415161718192021222324# 创建自己的进程类from multiprocessing import Processclass My_Process(Process): # def __init__(self, value): self.value = value # 调用Process的初始化方法 super(My_Process, self).__init__() def my_method(self): print(&quot;start....&quot;) def my_method2(self): print(&quot;end....&quot;) def run(self) -&gt; None: self.my_method() self.my_method2()if __name__ == &#x27;__main__&#x27;: process = My_Process(&quot;None&quot;, ) process.start() 多线程线程的认识 线程是程序运行的最小执行单位 线程thread是操作系统进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位 多线程的实现方式 与多进程的一般实现方法一致 定义自己的线程类 12345678910111213# 定义自己的线程类class my_thread(Thread): def __init__(self, value): self.value = value super().__init__() def run(self) -&gt; None: hello(self.value)# if __name__ == &quot;__main__&quot;:# th = my_thread(&#x27;hello,world&#x27;)# th.start() 定时器 123456789101112131415161718from threading import Timer# 停顿自定义的时间后，才会执行def print_str(str): print(f&quot;hello,&#123;str&#125;&quot;)t_list = []for i in range(3): t = Timer(3, print_str, args=(f&quot;person&#123;i&#125;&quot;,)) t.start() t_list.append(t)print(&quot;主进程结束&quot;)for t in t_list: t.join(timeout=3) 多进程和多线程的对比 对于IO密集型一般用多线程，对于计算密集型，一般用多进程。 多进程下的资源是无法共享的，也就是读取的资源可能不同步，但是共享全局变量；而多线程一般是在同一个进程中，所以其中的资源是共享的。 多线程的一个进程中的主线程会等待其下所有的子进程结束后结束，而多进程的主进程在不添加阻塞（join）的情况下，不会等待子进程结束。 协程协程的认识定义​ 由程序员自己写程序来管理的轻量级线程叫做用户空间线程，也叫纤程线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。 特点（优势） 可以把它看作一个函数，由程序员自己决定切换任务的执行。 由于不需要切换线程，也就减小了开销，更能合理的利用cpu的资源 只在一个线程里，不存在写变量冲突，也就不用加锁，执行效率比多线程高很多。 实现方式 yield 实现 用生成器实现，通过send方法，设置提交表达式为None，自己设置下一个提交的值，从而实现用户自己的调度。 gevent模块 123456789101112131415161718192021222324import timeimport geventfrom gevent import monkey# 打补丁，修改python自带的标准库为非阻塞，将耗时的代码修改为内置的代码monkey.patch_all()def task1(): print(&quot;task1start&quot;) time.sleep(1) print(&quot;task1end&quot;)def task2(): print(&quot;task2start&quot;) time.sleep(1) print(&quot;task2end&quot;)s = time.time()g1 = gevent.spawn(task1)g2 = gevent.spawn(task2)g1.join()g2.join()e = time.time()print(e-s) 参考资料 (12条消息) python高级编程 —- 多任务编程_多进程编程 &amp; 多线程编程 &amp; 协程_biggirler的博客-CSDN博客 一文读懂什么是进程、线程、协程（建议收藏） (360doc.com) (12条消息) 【Python】Python多任务第1篇：多进程、多线程与协程通俗易懂的理解方式_岚清子的博客-CSDN博客 (12条消息) 【Python】Python多任务第2篇：多线程、多进程与协程的代码实现范例_岚清子的博客-CSDN博客","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"python在import时的问题","slug":"python绝对路径和相对路径的引用","date":"2022-03-01T00:03:01.000Z","updated":"2022-03-04T12:45:25.920Z","comments":true,"path":"2022/03/01/python绝对路径和相对路径的引用/","link":"","permalink":"https://pursur314.github.io/2022/03/01/python%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E5%BC%95%E7%94%A8/","excerpt":"","text":"同目录下导入模块会报错 在一个学习案例中，运行Process_run.py报如下的错误 12ModuleNotFoundError: No module named &#x27;s_handler&#x27; 同一个目录下无法导入模块， 这是因为PyCharm不会将当前文件目录自动加入source_path，source_path为执行文件所在的目录，自然找不到在core目录下的s_handle模块。 解决方式： 将该目录设置为Source root 在s_handle模块中加入如下代码 12import syssys.path.append(&quot;s_handle模块所在目录的绝对路径&quot;) (11条消息) PyCharm同目录下导入模块会报错的问题_一颗小甜心的博客-CSDN博客 +++ python包相对导入时出现的错误在from . import XXX 或from .。 import XXX 时，即想要调用父目录下的模块报错 在process中调用setting模块 123ValueError: attempted relative import beyond top-level packageSystemError: Parent module &#x27;&#x27; not loaded, cannot perform relative importImportError: attempted relative import with no known parent package 要被python解释器视作一个包需要满足以下条件： 文件夹中必须含有__init__.py文件 不能作为调用包的顶层来作为程序执行入口 注意：在”from YY import XX”这样的代码中，无论是XX还是YY，只要被python解释器视作package，就会首先调用该package的__init__.py文件。如果都是package，则调用顺序是YY，XX。 解决办法： 将相对路径变为绝对路径 把执行文件放在调用的包目录外，顶层脚本的名称为__main__,该目录即使有__init__.py文件，也不会被视作一个包，由于没有..（名称中不包含文件路径）自然无法使用，自然无法使用from .. import 。 导入模块最万无一失的方法 1234import osimport sysos.chdir(os.path.dirname(__file__))sys.path.append(&quot;..&quot;) Python包的相对导入时出现错误的解决方法 - 青山牧云人 - 博客园 (cnblogs.com) (10条消息) python包导入细节（attempted relative import beyond top-level package的原因解读）_岁月如歌-CSDN博客 python模块相对路径引用错误处理 - 江风引雨の小po站 (luzy.top) +++ 相对引用和绝对引用的优缺点分析绝对引用优点是清晰且直接，可以很容易就确定引用文件位置；且即使当前文件的位置发生变化，导入语句仍然有效。缺点是当引用路径较为复杂时，导入语句很长，如： 1from package1.subpackage2.subpackage3.subpackage4.module5 import function6 相对引用最直观的优点就是简洁，在包层次结构较为复杂时，相对引用能够借助于以较短的代码实现快速的引用。缺点是较为凌乱，在项目文件位置发生变更时，不易维护；此外，相对引用可读性较差。较难根据引用代码确定引用文件路径。 版权声明：本文为CSDN博主「勤奋的清风」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。https://blog.csdn.net/qq_23926575/article/details/107510234","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"pickle和json模块","slug":"pickle和json模块","date":"2022-01-20T02:36:03.000Z","updated":"2022-02-11T03:05:47.415Z","comments":true,"path":"2022/01/20/pickle和json模块/","link":"","permalink":"https://pursur314.github.io/2022/01/20/pickle%E5%92%8Cjson%E6%A8%A1%E5%9D%97/","excerpt":"","text":"python的序列化模块​ 序列化：把对象或变量从内存中变成可储存或传输的过程称为序列化 pickle 模块​ 把对象序列化为python可识别的对象，且不同版本可能不兼容，相对不重要 json 模块​ json表示出来是一个字符串，不同的编程语言都可以读取，所以可以在不同的编程语言中传递对象。​ 函数​ 序列化：dumps生成一个字符串，dump生成一个字符串并保存到文件里，有两个参数​ 反序列化：loads和load（相当于eval（）），区别和dump一样，但读取文件，且都只有一个参数​ 注意：在储存文件时不能有空行，且字典类型全部都要用双引号，不然json识别不了","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"python中特殊的赋值方法","slug":"python中特殊的赋值方法","date":"2022-01-20T01:57:42.000Z","updated":"2022-01-20T02:17:01.330Z","comments":true,"path":"2022/01/20/python中特殊的赋值方法/","link":"","permalink":"https://pursur314.github.io/2022/01/20/python%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95/","excerpt":"","text":"链式赋值可以通过这样简洁的方式，减少代码行数 12a = b = 1print(a,b) 交叉赋值一种可以不需要第三个变量，就可以交换两个变量的值的方法，优雅而简洁。 1234a,b = 1,2# 在赋值的过程中，右侧的变量，不会随着左侧的变量值改变而改变a,b = b,a print(a,b) 解压赋值123a = [1,2,3] # a可以为任意序列类型b,*c = aprint(b,c) #注意c可以为空，但只会是列表","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"逻辑运算符的短路运算","slug":"逻辑运算符的短路运算","date":"2022-01-20T01:45:18.000Z","updated":"2022-01-20T01:54:50.761Z","comments":true,"path":"2022/01/20/逻辑运算符的短路运算/","link":"","permalink":"https://pursur314.github.io/2022/01/20/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97/","excerpt":"","text":"逻辑运算符的短路运算一般逻辑运算符and or not多用于与if等判断语句搭配，这是逻辑判断功能，但它实际还有运算功能。 +++ and 若第一个为true，返回第二个的值 1234a = 8 and 7 # a = 7print(a)a = 0 and 7 # a = 0print(a) or若第一个为true，返回第一个的值 1234b = 8 or 7 # b = 8print(b)b = 0 and 7 # b = 7print(b) +++ 根据这样的用法，对于一些特殊场景，便可以加以巧妙利用 注意 优先级顺序：not &gt; and &gt; or not是从右往左，and 和 or 是从左往右","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"__name__ = __main__的理解","slug":"name-main-的理解","date":"2022-01-17T08:42:06.000Z","updated":"2022-02-26T12:32:52.083Z","comments":true,"path":"2022/01/17/name-main-的理解/","link":"","permalink":"https://pursur314.github.io/2022/01/17/name-main-%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"name = main的理解__name__ == &quot;__main__&quot;一开始很疑惑为什么要用，直接run运行不就得了？ __name__和__main__都是python的内置的属性之一，在python的模块中，表示该模块名称，在python文件中也就是该文件名 在a.py文件中运行时，(a.py)__name__ == (a.py)&quot;__main__&quot;，但是是运行的在import的过程中，导入a 文件，导入的是a，没有后缀也就不会执行main下的语句。 假设是运行的文件是b.py，导入了a（不是a.py) __name__也就不等于__main__而是a 注意 import多次导入同一个模块时会以第一个模块的内容为标准 import如果在其他模块导入中重复导入会导致导入不完全","categories":[{"name":"问题记录","slug":"问题记录","permalink":"https://pursur314.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"git的使用","slug":"git的使用","date":"2022-01-15T16:00:00.000Z","updated":"2022-01-16T12:58:28.215Z","comments":true,"path":"2022/01/16/git的使用/","link":"","permalink":"https://pursur314.github.io/2022/01/16/git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"git的学习使用 参考网站 Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com) git的安装步骤 (5条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装 我翻阅过的比较详细的安装步骤，如果想详细了解可以参考， 实际上不断点下一步就好了 +++ git的基本概念 工作区：就是你当前的文件目录 暂存区：相当于于缓存区，你每次修改后都要添加到，其实相当于给你一次后悔的机会 仓库：与github的远程仓库连接的地方，可以看作你的备份 git的基本命令![屏幕截图 2022-01-14 145241](img/git的使用/屏幕截图 2022-01-14 145241.png) 更详细可以参考 git-cheat-sheet (gitee.io) 操作步骤和详细说明1.创建一个仓库最好选择一个空目录 1234git init# 将当前目录转化为一个git仓库git status# 查看当前仓库状态，以后会经常用到 2. 添加文件你在当前目录下创建一个test.txt文件,然后 1234# 添加到暂存区（stage）git add + filename# 提交到git的仓库（repository）git commit -m + &quot;messsge(提示信息)&quot; 注意， 你可以添加多个文件到stage，然后一次提交commit到git的仓库。 当使用git commit而不使用git commit -m命令时，会进入到vim编辑器 按下字母键i或a或o，此时进入到可编辑状态，这时就可以输入你的注释 当你输入完之后，按下Esc键就可退出编辑状态，回到一般模式。 最后就是怎么退出vim编辑器并提交commit， 有两种方法： 输入两字大写字母ZZ（记住是大写） 输入:wq或:wq!(强行退出) 3. 修改文件当你对文件修改后，可以对比 然后直接操作添加文件的步骤 可是如果你后悔了，但还文件没有提交到仓库 12345# 撤销工作区的修改git checkout -- filename# checkout 是对比的意思# 撤销暂存区的添加git reset head filename 很不幸，已经提交到仓库了（但还没有push） 1234567# 回到上一次git reset --hard + head^# 你又后悔了，想回到未来git reset --hard + commitid# --hard 是强制的意思，如果不添加git reset # 撤销所有暂存区的修改，文件的修改不会消失git reset --hard # 撤销所有暂存区的修改，文件的修改消失 怎么查看commitid 1234# 显示到当前时间提交的记录git log -limit（显示的记录数量）# 显示所有的修改记录（要回到未来，你只能查看这个）git reflog 4.删除文件在工作区删除，直接删就完事了 但要删除仓库的文件 123# 注意会连同你工作区的文件一起删除git rm + filename# 删除后也算一次修改，不用add 但需要commit +++ git的分支管理基本操作一般来说可能会用到的操作 1234567891011121314# 查看所有分支git branch# 创建一个新分支git branch + name# 切换到新分支git switch + name# 创建并切换到新分支git switch -c + name# 与当前分支合并git merge + name（要合并的当前分支的分支名称）# 删除合并后的分支git branch -d + name#强制删除分支，即使在这个分支上还有文件没有提交git branch -D + name 还记得可以用git log 查看合并的历史？ 其实有图像化界面 12# 合并的历史图形化界面git log --graph +++ 管理策略在进行分支合并的时候默认进行的是 fast forward（快进） 在这种模式下，在git 会默认将head 指针移到一个最新的阶段 在禁用fast forward后，相当于对当前的分支进行了一次提交，对不同的分支，会存在不同的提交历史，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 +++ 这是要合并的状态 没禁用 禁用后 在多人合作时强烈建议使用–no-ff 疑难杂症解决冲突 如果你创建了一个新分支dev，且和当前主分支的处于同一个进度，但是文件的内容不一样？ 12# 首先试一试git merge + branchname 好吧，合并失败了，需要我们手动保留你想要的内容，打开文件，修改内容 最后，继续 12git add + filenamegit commit -m &quot;message&quot; bug分支 对于当前的工作没做完，还不能提交需要切换到另一个分支时，我们需要保留当前的工作环境 123456# 保留当前的工作环境git stash# 恢复工作环境并删除记录git stash pop = git stash apply stash@&#123;0&#125; + 和 git stash drop# 查看记录git stash list 如果刚才修改了一个分支上的问题，而其他的分支上也有相同的问题，那么还有继续修改未免太麻烦了 12# 复制某次提交所做的修改git cherry-pick + commitid 多人协作远程库的连接先在GitHub上创建一个本地库，然后关联远程库 1234567891011# 关联一个远程库时git remote add origin（默认为远程仓库名）git@github.com:+username\\+respositoryname# 推送内容：git push（-u：第一次使用，使远程库和当地文件的分支关联）+ origin（远程仓库名）+ master（推送分支名）# 查看远程仓库git remote -v# 删除远程库的关联git remote rm origin（远程仓库名）# 克隆远程库git clone git@github.com:+username\\+respositoryname 合作过程的注意事项 首先，你的小伙伴需要git clone,把主分支master上的内容复制到本地目录，注意，只会复制主分支 手动关联到其他分支 1git switch -c branchname origin/branchname 推送内容失败？你的小伙伴可能把修改提交到远程库，所以远程的分支比本地更新 123456# 合并远程内容git pull # git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;# 还是不行？其实合并了，但产生了冲突，解决方法同上面一样# 最后的解决办法，抓取所有远程分支并如本地git pull --rebase 标签管理每次提交都会给有一个id，为了更好的说明，可以给这次提交打上标签。 1234567# 默认会给最新的提交打上标签git tag + tagname + （commitid）# 查看标签git tag# 删除标签git tag -d tagname (本地)git push origin :refs/tags/&lt;tagename&gt; +++ 自定义git忽略特殊文件总会有一些你不想上传到GitHub上的文件，或者密钥等重要文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 所有配置文件可以直接在线浏览：https://github.com/github/gitignore 配置别名建议在文件修改：.git/config中的【alias】下，设置全局则在c盘用户目录的.gitconfig中 也可以使用命令修改 12# 模板，修改status命令为stgit config --global alias.st status","categories":[{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"git","slug":"git","permalink":"https://pursur314.github.io/tags/git/"},{"name":"软件","slug":"软件","permalink":"https://pursur314.github.io/tags/%E8%BD%AF%E4%BB%B6/"}],"author":"pursur"},{"title":"github的快速访问","slug":"github的快速访问","date":"2022-01-14T06:33:02.000Z","updated":"2022-01-14T06:41:28.715Z","comments":true,"path":"2022/01/14/github的快速访问/","link":"","permalink":"https://pursur314.github.io/2022/01/14/github%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE/","excerpt":"","text":"github的快速访问 (5条消息) 访问GitHub加速，配置Host文件_Harryの心阁-CSDN博客_github host 总结以下方法 修改host文件，具体步骤参考上方链接 翻墙，这里就不提供方法了，（谨慎） 使用国内的Git托管服务——Gitee（gitee.com）。","categories":[{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"github","slug":"github","permalink":"https://pursur314.github.io/tags/github/"}],"author":"pursur"},{"title":"git文件上传出错","slug":"git文件上传出错","date":"2022-01-13T11:31:39.000Z","updated":"2022-01-14T02:12:55.388Z","comments":true,"path":"2022/01/13/git文件上传出错/","link":"","permalink":"https://pursur314.github.io/2022/01/13/git%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%87%BA%E9%94%99/","excerpt":"","text":"git上传文件出错在将自己的代码上传到github上时，报这样的错误 ![屏幕截图 2022-01-13 193443](../../../../图片/Camera Roll/屏幕截图 2022-01-13 193443.png) +++ 查阅他人的资料 [git上传文件出错rejected] master -&gt; master (fetch first) error: failed to push some refs to ‘ - 简书 (jianshu.com) 因为github中的README.md文件不在本地代码目录中，可以通过如下命令进行代码合并 git pull –rebase origin master git push origin master +++ 我的问题在于创建了一个新目录 没有克隆GitHub下的文件到当前目录","categories":[{"name":"问题记录","slug":"问题记录","permalink":"https://pursur314.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"git","slug":"git","permalink":"https://pursur314.github.io/tags/git/"}],"author":"pursur"},{"title":"深入类和对象","slug":"深入类和对象","date":"2022-01-13T09:01:44.000Z","updated":"2022-02-13T03:11:22.853Z","comments":true,"path":"2022/01/13/深入类和对象/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"三. 深入类和对象鸭子类型和多态 什么是鸭子类型？（python的核心） 只要行为，性格像鸭子，就把它看作鸭子。在python中，其实就是只要具有相同的方法，那么就可以把它归为一类对象。 例如list，set，tuple都是可迭代对象，都是一只鸭子（他们都包含一些相同的魔法函数） 多态 同一种事物，但具有不同的形态，人和其他动物都是动物，都可以走，但人和其他动物不一样，由此体现了动物的多态。 在python中，多态可以通过继承的方式体现，子类可以调用父类的方法函数 多态性（注意和多态的区分） 多个不同功能的函数，具有相同的函数名，在python中，python本身就具有多态性，对于不同的类对象，可以有相同的函数名，但实现的功能不一样，我们都可以用相同的方法进行调用 123456789101112131415161718192021222324252627282930# dclass Animal: def run(self): raise AttributeError(&#x27;子类必须实现这个方法&#x27;) # 体现多态class People(Animal): def run(self): print(&#x27;人正在走&#x27;) class Pig(Animal): def run(self): print(&#x27;pig is walking&#x27;) class Dog(Animal): def run(self): print(&#x27;dog is running&#x27;) peo=People()pig=Pig()dog=Dog() # 体现多态peo.run()pig.run()dog.run()animal = [peo,pig,dog]for i in animal: i.run() # 体现多态性 +++ 抽象基类 目的 为了判断某个对象的类型 为了使某个对象的子类必须实现父类的某些方法 12345678910111213141516171819202122232425262728293031#使子类在实例化时就抛出异常class A(metaclass= abc.ABCMeta): @abc.abstractmethod def get(self,key): pass @abc.abstractmethod def getvalue(self,key,value): passclass B(A): passB() # 抛出异常#使子类在调用父类方法时抛出异常class C(): def get(self,key): raise NotImplementedError def getvalue(self,key,value): raise NotImplementedErrorclass D(C): passtestD = D()testD.get(&quot;dk&quot;) # 抛出异常 +++ type和isinstance的区别 type实质返回的是将该对象实例化的类，不能判断是否是该类的父类将其实例化 isinstance（）实质判断的是是否属于该类型，也就可以判断与父类的关系 1__base__ # 可以查看所有的基类 +++ 类的深入 类的属性和实例属性及其查找顺序 类和他的实例是两个不同的对象，在查找其属性时自下而上查找 多继承的查找方法 c3算法：python 独有的mro算法，解决钻石（菱形）的继承问题，以及Y型问题 123456789101112131415161718192021222324252627282930313233# 菱形继承# 当一个类d继承的两个类b，c中继承了相同的一个类a，而继承的b，c类中均对a中的同一个方法进行了改写，具有不同的功能，由此产生问题class a1(): passclass b1(a1): passclass c1(a1): passclass d1(b1,c1): passprint(d1.__mro__)# y型继承class a2(): passclass b2(): passclass c2(a2): passclass d2(b2): passclass e2(c2,d2): passprint(e2.__mro__) 总结：本地优先，先在本地查找，然后按继承的列表顺序查找，如果在查找的父类中继承了其他类，那么继续向上查找，没有的话才会查找相同级别的下一个父类 静态方法和类方法以及实例方法的区别 静态方法和类方法不需要实例化就可以实现，而实例方法需要实例化后才可以实现 静态方法没有传入该类，需要用@staticmethod 装饰器 类方法传入了所在类，cls（类似于self，但self传入的是实例对象），需要用@classmethod 装饰 总结：逻辑上，类方法应该只被类调用（也可以被实例化对象调用），静态方法，两者都能被调用，实例方法只能被实例化后的对象调用。 类的私有变量和私有方法 （变量和方法都是该类的属性） 在属性或方法前加双下划线，但不是绝对私有化，可以通过_class__attr得到， 只能在该对象的内部使用，其子类或实例都不能调用 123456789101112131415161718192021222324class Date(object): __initiu_date = &quot;0000_00_00&quot; def __init__(self,year,month,day): self.year = year self.month = month self.day = day def __parse_date(string): year,month,day = tuple(string.split(&quot;-&quot;)) return Date(year,month,day) def parsing_date(cls,string): year, month, day = tuple(string.split(&quot;-&quot;)) return cls(year, month, day) def __str__(self): return f&quot;&#123;self.month&#125; &#123;self.day&#125; &#123;self.year&#125;&quot;date = &quot;2021-11-8&quot;today = Date.parsing_date(date)toda = Date._Date__parse_date(date) #得到私有方法print(today,toda)print(today._Date__initiu_date) #得到私有变量","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"魔法函数","slug":"魔法函数","date":"2022-01-13T08:59:46.000Z","updated":"2022-01-22T03:15:25.491Z","comments":true,"path":"2022/01/13/魔法函数/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/","excerpt":"","text":"二.魔法函数什么是魔法函数？以双下划线（__)开头和结尾的，python内置，解释器自动调用，用户无法定义其名称的函数 魔法函数的影响 改变或增加对象的类型 魔法函数实际是python的一种数据模型，能够对内部进行优化，提高性能 +++ 由于魔法函数过多，其后会慢慢学习，只选用几个例子 +++ 魔法函数的例子123456789101112131415161718192021222324class company(object): &quot;&quot;&quot; 通过__doc__查看 &quot;&quot;&quot; def __init__(self,employee): self.employee = employee #变成一个可迭代类型的对象（与iter类似） def __getitem__(self,item): return self.employee[item] #变成一个y类型的鸭子对象 def __len__(self): return len(self.employee) def __str__(self): &quot;&quot;&quot;变成一个str类型的对象&quot;&quot;&quot; return &quot;.&quot;.join(self.employee)com = company([&quot;petter&quot;,&quot;Tom&quot;])for item in com: print(item) python的with语句满足python自带的上下文管理器协议协议内容： 在用with语句时，获取资源时自动调用 enter 魔法函数，释放资源时自动调用 exit 魔法函数 定义其上两个魔法函数后便可以使用with 语句打开 1234567891011121314151617181920# 实质上跟函数的装饰器差不多，可以让类添加额外的方法class with_method: &quot;&quot;&quot;进入时自动调用的方法&quot;&quot;&quot; def __enter__(self): print(&quot;enter&quot;) return self def use_method(self): print(&quot;using!!!&quot;) pass &quot;&quot;&quot;退出时自动调用的方法&quot;&quot;&quot; def __exit__(self, exc_type, exc_val, exc_tb): print(&quot;exit&quot;) passwith with_method() as fp: fp.use_method()","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"一切皆对象","slug":"一切皆对象","date":"2022-01-13T08:54:30.000Z","updated":"2022-01-13T08:58:12.993Z","comments":true,"path":"2022/01/13/一切皆对象/","link":"","permalink":"https://pursur314.github.io/2022/01/13/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一. 一切皆对象python中，一切皆对象什么是对象？ 可以被赋值给一个对象 可以被添加到一个列表或其他序列中，作为一个元素 可以被用作参数传递，或返回值返回 +++ 对象的类型 python基本的数据类型，像列表，是一个列表对象，除此之外，还有很多，像生成器，迭代器对象等 +++ type 与object，class 的关系 object是每一个类都必须要继承的一个基类，是type的实例 type 是最基础的类，自己实例化自己，继承object class 保留关键字，定义类 123print(type(object))print(type(type))print(type(int)) 结果都是type的实例对象 +++ 静态语言和动态语言的区别pyhton是一门动态语言 静态语言需要指定每一个变量的类型，动态语言不用 静态语言需要一个编译过程，可以发现错误，而动态语言不需要，只有运行时才能发现错误 静态语言的多态需要继承，而动态语言与生俱来","categories":[{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"}],"author":"pursur"},{"title":"typora的使用","slug":"typora的使用","date":"2022-01-09T08:30:33.000Z","updated":"2022-01-16T09:11:24.644Z","comments":true,"path":"2022/01/09/typora的使用/","link":"","permalink":"https://pursur314.github.io/2022/01/09/typora%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"markdown 语法 完整更详细的操作参考 (6条消息) 最齐的Typora使用教程_水木子的博客-CSDN博客_typora使用教程 只罗列了一些平常写博客用的多的操作 标题 ctrl + 数字键（数字对应几级标题，一共六级），注意ctrl +0 是普通段落 #加上一个空格，然后才是标题内容 字体 斜体 用一对 * 或 _ 括住的字体表示斜体 斜体 ctrl + I 粗体 用一对 ***或___括住的字体表示粗体 ctrl + B 各种线 分割线 连续的三个* 或+ 或-： +++ 删除线 用一对~~括住的文本 删除线 下划线 ctrl + U 序列 无序序列 ctrl + shift + 】 用+或*或- 加上一个空格来表示 有序序列 ctrl + shift +【 用数字加上一个空格来表示 第一个 第二个 列表的嵌套 第一项 第二项 第一项 第一项 缩进的距离 tab 或者 ctrl + 【 引用 使用 &gt;加上空格，用于引用他人文章的内容 快捷键 ctrl + shift +q 退出 delete 或 enter 引用的内容 引用的嵌套 一级 二级 代码 ctrl + shfit + k 如果是一行代码，可以使用段内代码块来表示，用一对 **`**（数字1旁边的符号）括住代码。 退出代码块：ctrl + enter print(&quot;hello,world&quot;) 链接 ctrl + K 这是菜鸟链接 图片 ctrl + shift + I ![本地图片](../../../../图片/Camera Roll/wallhaven-pkgkkp.png) 可以直接复制粘贴图片 ，但需要在偏好设置中设置一下图片的保存地址 表格 ctrl + T 对齐方式 这是左对齐 这是右对齐 中间对齐 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格","categories":[{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://pursur314.github.io/tags/%E8%BD%AF%E4%BB%B6/"}],"author":"pursur"},{"title":"hexo+github的博客搭建","slug":"hexo-github的博客搭建","date":"2022-01-08T08:30:33.000Z","updated":"2022-01-18T07:39:11.592Z","comments":true,"path":"2022/01/08/hexo-github的博客搭建/","link":"","permalink":"https://pursur314.github.io/2022/01/08/hexo-github%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"hexo+github的博客搭建说起博客的搭建过程，作为一个小白，真是受尽了九九八十一难，但功夫不负有心人 +++ 搭建过程参考的网站 【2021最新版】保姆级Hexo+github搭建个人博客_哔哩哔哩_bilibili (7条消息) 使用 github 仓库搭建 Hexo教程，Hexo配置文件解读，Hexo安装next主题及主题配置，美化_sywdebug的博客-CSDN博客_hexo安装next主题 Documentation | Hexo 更换主题参考的网站 GITHUB+HEXO博客轻松更换主题外观 - 简书 (jianshu.com) (7条消息) hexo博客更换主题后，本地服务器运行成功，部署到github上就不能显示主题样式_MFMLN~ 星辰大海-CSDN博客 Volantis: 站点配置 - Volantis +++ 总结不管干啥，首先看看有没有官网教程，一千个人就有一千个哈姆莱特，每个人情况都不一样，要是遇到问题了再度娘或再CSDN上找找，如果官网看不懂，再找他人的博客参考","categories":[{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"github","slug":"github","permalink":"https://pursur314.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://pursur314.github.io/tags/hexo/"}],"author":"pursur"},{"title":"Hello World","slug":"hello-world","date":"2022-01-08T02:40:25.924Z","updated":"2022-01-08T02:39:21.837Z","comments":true,"path":"2022/01/08/hello-world/","link":"","permalink":"https://pursur314.github.io/2022/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pursur314.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"问题记录","slug":"问题记录","permalink":"https://pursur314.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"教程","slug":"教程","permalink":"https://pursur314.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"python的高级编程","slug":"python的高级编程","permalink":"https://pursur314.github.io/categories/python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://pursur314.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"python","permalink":"https://pursur314.github.io/tags/python/"},{"name":"git","slug":"git","permalink":"https://pursur314.github.io/tags/git/"},{"name":"软件","slug":"软件","permalink":"https://pursur314.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"github","slug":"github","permalink":"https://pursur314.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://pursur314.github.io/tags/hexo/"}]}